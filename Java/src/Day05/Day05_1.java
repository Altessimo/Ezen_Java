package Day05;

public class Day05_1 {
/*
 * 1. 출력
 * 2. 입력
 * 1, 2 : 프론트 → Html
 * 3. 데이터 저장(변수) : 자료형(8가지)
 * 4. 데이터 연산(연산자) : 산술, 비교, 논리, 대입, 증감, 조건
 * 5. 제어문 / 반복문
 * 		3 ~ 5 1달안에 완벽해야 함
 * 5. 배열
 */
	public static void main(String[] args) {
		
		// 복습
		 // 변수 : 미리 정해진 크기상자(자료형)의 데이터 저장
		// 1. 자료형(상자크기) 2. 변수명(상자이름) 3. 초기값(상자의 내용물)
		
		int 변수 = 10; // 4바이트 (주소가 4개 생김, 1바이트당 주소 1개)
			// 많은 변수가 필요할때 선언과 관리 효율 떨어짐
		
		// 배열 : 동일한 크기상자(자료형)의 여러개 변수 선언
			// 1. 자료형 2. 배열명 3. 배열길이[변수개수]
			// 2. 저장되는 순서 : 인덱스[0~배열길이 -1] = 0~9까지
			// 3. 배열의 단점 : 메모리 효율성 감소 ←----→  리스트
		
		// 변수 / 배열 → 메모리
			// 1. 메모리는 하나의 자료형의 크기만큼 주소값[16진수 : 생성]
			// 2. 컴퓨터는 주소값을 통한 메모리 접근
		
		// 1차원 배열 : 배열의 길이 12345 // 가로만 있음
		int[] 배열 = new int[3]; // int : 4바이트 * 10 → 배열 크기는 40바이트
		배열[0] = 80; 배열[1] = 90; 배열[2] = 100;
		
		// 2차원 배열 : 배열의 [가로길이=행][세로길이=열] // 4바이트 * 2 * 3 → 24바이트
		int[][] 배열2 = new int[2][3];
		배열2[0][0] = 80; 배열2[0][1] = 90; 배열2[0][1] = 100;
		배열2[1][0] = 40; 배열2[1][1] = 50; 배열2[1][2] = 60;
		
		System.out.println("2차원 배열 : " + 배열2);
		System.out.println("배열[0][0] : " + 배열2[0][0]);
		System.out.println("배열 전체 가로 길이 : " + 배열2.length);
		System.out.println("배열 전체 세로 길이 : " + 배열2[0].length);
		
		// 문제 1 : 반복문을 이용한 0~49까지 첫번째 행에 저장
			// 50~99까지는 두번째 행에 저장하는 2차원 배열 선언하고 출력
		
		int[][] 배열4 = new int[2][50]; // 4바이트 * 2 * 50 = 400 바이트
		for(int i = 0; i<100; i++) { // i는 0 부터 100미만까지 1씩 증가하면서 반복
			if(i<50) 배열4[0][i] = i; // 해당 i 인덱스의 i값 넣기
			else 배열4[1][i-50] = i; // -50하는 이유 : 현재 값이 50까지 밖에 없어서 99를 채우기에는 무리가 있기 때문에
	}
	// i가 0일때 배열[0][0] = 0
	// i가 1일때 배열[0][1] = 1 ----- i가 49일때 배열[0][49] = 49
	// i가 50일때 배열4[1][(50-50)0] = 50 ----- i가 99일때 배열4[1][(99-50)-49] = 99
		for(int i=0; i<100; i++) {
			if(i<50) System.out.printf("[%2d]", 배열4[0][i]);
			else System.out.printf("[%2d]", 배열4[1][i-50]);
			
			if(i==49) System.out.println();
		}
			
		// 3차원[디자인] 배열 : 배열의 [가로길이][세로길이][높이길이]
		int[][][] 배열3 = new int[10][10][10];
	} // m e
} // c e
